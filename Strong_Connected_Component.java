import java.util.*;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int V = sc.nextInt();        int E = sc.nextInt();        Map<Integer,ArrayList<Integer>> G = new HashMap<>();        Map<Integer,ArrayList<Integer>> RG = new HashMap<>();        int [] Group = new int[V];        Arrays.fill(Group,-1);        for(int i=0;i<E;i++){            int s = sc.nextInt();            int t = sc.nextInt();            if(G.get(s)==null){                ArrayList<Integer> st = new ArrayList<>();                st.add(t);                G.put(s,st);            }            else G.get(s).add(t);            if(RG.get(t)==null){                ArrayList<Integer> ts = new ArrayList<>();                ts.add(s);                RG.put(t,ts);            }            else RG.get(t).add(s);        }        ArrayList<node> L = new ArrayList<node>();        ArrayList<Integer> check = new ArrayList<>();        for(int i=0;i<V;i++) if(!check.contains(i)) DFS(G,i,L,check);        int cnt = 0;        //for(node n:L) System.out.println(n.n+":"+n.s);        Collections.sort(L, new Comparator<node>() {            @Override            public int compare(node o1, node o2) {                return o1.n<o2.n?1:-1;            }        });        check = new ArrayList<>();        for(node v:L){            if(!check.contains(v.s)){                Group[v.s] = cnt;                Group = RDFS(Group,RG,v.s,check,cnt);                cnt++;            }        }        int q = sc.nextInt();        for(int i=0;i<q;i++){            int s = sc.nextInt();            int t = sc.nextInt();            //System.out.print(s+"-"+t+":"+Group[s]+","+Group[t]+"=");            if(Group[s]==Group[t]) System.out.println(1);            else System.out.println(0);        }    }    /**    *DFSの場合深くなりすぎてメモリエラーを起こす     *DFS：帰りがけの番号の割り振り方にミスがある     */    public static void DFS(Map<Integer,ArrayList<Integer>> G,int now,ArrayList<node> L,ArrayList<Integer> check) {        ArrayDeque<Integer> stack = new ArrayDeque<>();        ArrayList<Integer> allocation = new ArrayList<>();        Map<Integer,Integer> List = new HashMap<>();        ArrayDeque<Integer> Backward = new ArrayDeque<>();        stack.push(now);        while (stack.size() > 0) {            now = stack.pop();            //System.out.println(now);            check.add(now);            if(List.get(now)==null) List.put(now,0);            boolean ch = false;            if (G.get(now) != null) {                for (int v : G.get(now)) {                    if (!check.contains(v)) {                        ch = true;                        stack.push(v);                        List.replace(now,List.get(now)+1);                    }                }            }            if (!ch ) {                if(!allocation.contains(now)) {                    L.add(new node(now, L.size() + 1));                    allocation.add(now);                }                while(Backward.size()>0){                    int back = Backward.pop();                    List.replace(back,List.get(back)-1);                    if(List.get(back)==0){                        L.add(new node(back, L.size() + 1));                        allocation.add(back);                    }                    else{                        Backward.push(back);                        break;                    }                }            }            else if(ch) Backward.push(now);        }    }    public static int [] RDFS(int Group[],Map<Integer,ArrayList<Integer>> G,int now,ArrayList<Integer> check,int cnt){        ArrayDeque<Integer> stack = new ArrayDeque<>();        stack.push(now);        while(stack.size()>0) {            now = stack.pop();            Group[now] = cnt;            check.add(now);            if (G.get(now) != null) {                for (int v : G.get(now)) {                    if (!check.contains(v)) {                        stack.push(v);                    }                }            }        }        return Group;    }    public static class node{        int s,n;        public node(int s,int n){            this.s = s;            this.n = n;        }    }}
import java.util.*;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int V = sc.nextInt();        int E = sc.nextInt();        Map<Integer,ArrayList<Integer>> G = new HashMap<>();        Map<Integer,ArrayList<Integer>> RG = new HashMap<>();        int [] Group = new int[V];        Arrays.fill(Group,-1);        /**         * @description:setting nodes and edges of a graph         */        for(int i=0;i<E;i++){            int s = sc.nextInt();            int t = sc.nextInt();            if(G.get(s)==null){                ArrayList<Integer> st = new ArrayList<>();                st.add(t);                G.put(s,st);            }            else G.get(s).add(t);            if(RG.get(t)==null){                ArrayList<Integer> ts = new ArrayList<>();                ts.add(s);                RG.put(t,ts);            }            else RG.get(t).add(s);        }        /**         * @description: first DFS         */        ArrayList<node> L = new ArrayList<node>();        ArrayList<Integer> list = new ArrayList<>();        ArrayList<Integer> check = new ArrayList<>();        check.add(0);        for(int i=0;i<V;i++) if(!list.contains(i)) DFS(G,i,L,check,list);        int cnt = 0;        check = new ArrayList<>();        for(int i=0;i<L.size();i++){            Collections.sort(L, new Comparator<node>() {                @Override                public int compare(node o1, node o2) {                    return o1.n<o2.n?1:-1;                }            });            node v = L.get(i);            if(!check.contains(v.s)){                Group[v.s] = cnt;                check.add(v.s);                Group = RDFS(Group,RG,v.s,check,cnt);                cnt++;            }        }        int q = sc.nextInt();        for(int i=0;i<q;i++){            int s = sc.nextInt();            int t = sc.nextInt();            if(Group[s]==Group[t]) System.out.println(1);            else System.out.println(0);        }    }    /**    *DFSの場合深くなりすぎてメモリエラーを起こす     * DFSとRDFSのあたいの割り当て方にミスがある     */    public static void DFS(Map<Integer,ArrayList<Integer>> G,int now,ArrayList<node> L,ArrayList<Integer> check,ArrayList<Integer> list){        ArrayDeque<Integer> stack = new ArrayDeque<>();        ArrayDeque<Integer> List = new ArrayDeque<>();        stack.push(now);        while(stack.size()>0){            now = stack.pop();            if(G.get(now)!=null){                ArrayList<Integer> l = G.get(now);                Collections.sort(l,Comparator.reverseOrder());                for(int v:l){                    if(!check.contains(v)){                        check.add(v);                        list.add(v);                        stack.push(v);                    }                }            }            List.push(now);        }        while(List.size()>0){            node n = new node(List.pop(),L.size()+1);            L.add(n);        }    }    public static int [] RDFS(int Group[],Map<Integer,ArrayList<Integer>> G,int now,ArrayList<Integer> check,int cnt){        ArrayDeque<Integer> stack = new ArrayDeque<>();        stack.push(now);        while(stack.size()>0) {            now = stack.pop();            if (G.get(now) != null) {                ArrayList<Integer> l = G.get(now);                Collections.sort(l,Comparator.reverseOrder());                for (int v : l) {                    if (!check.contains(v)) {                        check.add(v);                        Group[v] = cnt;                        stack.push(v);                    }                }            }        }        return Group;    }    public static class node{        int s,n;        public node(int s,int n){            this.s = s;            this.n = n;        }    }}
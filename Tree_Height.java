import java.util.*;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        Map<Integer,ArrayList<Edge>> L = new HashMap<>();        if(n>1) {            for (int i = 0; i < n - 1; i++) {                int s = sc.nextInt();                int t = sc.nextInt();                int w = sc.nextInt();                if (L.get(s) == null) {                    ArrayList<Edge> list = new ArrayList<>();                    list.add(new Edge(t, w));                    L.put(s, list);                } else L.get(s).add(new Edge(t, w));                if (L.get(t) == null) {                    ArrayList<Edge> list = new ArrayList<>();                    list.add(new Edge(s, w));                    L.put(t, list);                } else L.get(t).add(new Edge(s, w));            }            //直径算出、その経路かつ両端までの距離を算出O(n^2)　経路P（経路長：|P|）            int[] length = new int[n];            int[] P = new int[n];            Arrays.fill(P, -1);            length[0] = 0;            Edge source = DFS(0, L, length, P);            Arrays.fill(length, 0);            Arrays.fill(P, -1);            Edge sink = DFS(source.t, L, length, P);            ArrayList<Integer> path = Reverse(source.t, sink.t, P);            //直径の頂点に交わるまで親をたどり、その交点からの直径の両端点までの距離と辿ってきた距離を加算し、大きい方を算出((n-|P|)^2)            int[] solution = new int[n];            Arrays.fill(solution, 0);            for (int i = 0; i < n; i++) {                if (path.contains(i)) solution[i] = Math.max(length[i], length[sink.t] - length[i]);                else {                    int dis[] = Reverse2(i, P, L, path);                    solution[i] = Math.max(dis[0] + length[dis[1]], length[sink.t] - length[dis[1]] + dis[0]);                }                System.out.println(solution[i]);            }        }        else System.out.println(0);    }    public static Edge DFS(int root,Map<Integer,ArrayList<Edge>>L,int [] length,int [] P){        ArrayDeque<Integer> stack = new ArrayDeque<>();        ArrayList<Integer> check = new ArrayList<>();        Edge max_node = new Edge(-1,0);        stack.push(root);        while(stack.size()>0){            int now = stack.pop();            if(L.get(now)==null) continue;            check.add(now);            for(Edge e:L.get(now)){                if(!check.contains(e.t)){                    stack.push(e.t);                    P[e.t] = now;                    length[e.t] = Math.max(e.w+length[now],length[e.t]);                    if(max_node.w<length[e.t]){                        max_node.w = length[e.t];                        max_node.t = e.t;                    }                }            }        }        return max_node;    }    public static ArrayList<Integer> Reverse(int source,int sink,int [] P){        ArrayList<Integer> path = new ArrayList<>();        int now = sink;        for(int i=0;i<P.length;i++){            path.add(now);            if(now==source) return path;            now = P[now];        }        return path;    }    public static int[] Reverse2(int root,int [] P,Map<Integer,ArrayList<Edge>> L,ArrayList<Integer> path){        int now = root;        int [] max = new int[2];        for(int i=0;i<P.length;i++){            int p = P[now];            if(L.get(now)==null) continue;            for(Edge e:L.get(now)){                if(e.t==p) {                    max[0]+=e.w;                    break;                }            }            if(path.contains(p)){                max[1] = p;                break;            }            now = p;        }        return max;    }    public static class Edge{        int t,w;        public Edge(int t,int w){            this.t = t;            this.w = w;        }    }}
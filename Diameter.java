import java.util.*;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        Map<Integer,ArrayList<Edge>> L = new HashMap<>();        /*木構造のデータ初期化*/        for(int i=0;i<n-1;i++){            int s = sc.nextInt();            int t = sc.nextInt();            int w = sc.nextInt();            if(L.get(s)==null){                ArrayList<Edge> list = new ArrayList<>();                list.add(new Edge(t,w));                L.put(s,list);            }            else L.get(s).add(new Edge(t,w));            if(L.get(t)==null){                ArrayList<Edge> list = new ArrayList<>();                list.add(new Edge(s,w));                L.put(t,list);            }            else L.get(t).add(new Edge(s,w));        }        /*任意の頂点より最長となる頂点を探索（DFS)*/        Edge v = DFS(L,0,new int[n]);        /*１度目のDFSによって最長の頂点をルートとしてDFS実施*/        v = DFS(L,v.t,new int[n]);        System.out.println(v.w);    }    public static Edge DFS(Map<Integer,ArrayList<Edge>> L,int root,int [] length){        ArrayDeque<Integer> stack = new ArrayDeque<>();        stack.push(root);        Set<Integer> check = new HashSet<>();        Edge max_node = new Edge(-1,0);        while(stack.size()>0){            int now = stack.pop();            if(L.get(now)==null) continue;            check.add(now);            for(Edge e:L.get(now)){                if(!check.contains(e.t)){                    stack.push(e.t);                    length[e.t] = Math.max(e.w+length[now],length[e.t]);                    if(max_node.w<length[e.t]) {                        max_node.w = length[e.t];                        max_node.t = e.t;                    }                }            }        }        return max_node;    }    public static class Edge{        int t,w;        public Edge(int t,int w){            this.t = t;            this.w = w;        }    }}